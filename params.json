{"body":"# solr-parse\r\n\r\nI'm just a function really (`compile-query`).\r\n\r\n## dependency\r\n\r\nIn your `project.clj`, in the dependency key, add this:\r\n\r\n``` clj\r\n[solr-parse 0.1.0-SNAPSHOT]\r\n```\r\n\r\nThen\r\n\r\n``` clj\r\nlein deps\r\n```\r\n\r\nThen you're good\r\n\r\n## Usage\r\n\r\nThe idea is to be able to compute, given a function and a solr query, a clojure function able to query a clj data store.\r\n\r\nFor example, given a function 'default-transco' which takes 2 parameters and returns a list of data:\r\n\r\n``` clj\r\n(fact\r\n  (default-transco :a \"b\")\r\n    => '(= (m :a) \"b\"))\r\n```\r\n\r\nAnd a query:\r\n\r\n``` clj\r\n(fact\r\n  (compile-query default-transco \"(a:b AND c:\\\"d\\\") OR (e:f) OR g:h\")\r\n    => '(or (and (= (m :a) :b) (= (m :c) \"d\")) (= (m :e) :f) (= (m :g) :h)))\r\n```\r\n\r\nHere is another function `reverse-transco`:\r\n\r\n``` clj\r\n(fact\r\n  (reverse-transco :a \"b\")\r\n    => '(= (m \"b\") :a))\r\n```\r\n\r\nAnd the same query:\r\n\r\n``` clj\r\n(fact\r\n  (compile-query reverse-transco \"(a:b AND c:\\\"d\\\") OR (e:f) OR g:h\")\r\n    => '(or (and (= (m :b) :a) (= (m \"d\") :c)) (= (m :f) :e) (= (m :h) :g)))\r\n```\r\n\r\nIn this example:\r\n- `a:b`, `c:\"d\"`, `e:f`, and `g:h` are some key value pair which hold meaning in your context.\r\n- m represents something in your `default-transco` or `reverse-transco`\r\n\r\n## License\r\n\r\nCopyright Â© 2012 commiters\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","name":"Solr-parse","tagline":"compile a solr query into an equivalent clojure function","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}